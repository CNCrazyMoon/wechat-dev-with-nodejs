# co引出的“血案”

ES6的Generator本意是为了计算而设计的迭代器，但tj觉得它可以用于流程控制，于是就有了co，co的历史可以说经历了目前所有的流程控制方案，而且由于支持Generator和yield就导致yieldable。

实际上co和Generator是把双刃剑，给了我们强大便利的同时，也增加了非常多的概念，可能是过渡性的，也可能是过时的。

可是，你真的需要了解这么多么？从学习的角度，当然是多多意义，如果从实用的角度看，你可能不需要。

存在即合理，那么我们就看看这“血案”吧:

- 学习ES6的Generator
- 了解ES6的迭代器和迭代器相关的2种协议，了解for-of
- 了解co和co的2种用法，源码
- 了解yieldable 5种（包括不常用Thunk）
- 如果是koa，还需要了解convert和compose
